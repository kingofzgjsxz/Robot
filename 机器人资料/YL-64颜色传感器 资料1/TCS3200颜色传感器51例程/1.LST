C51 COMPILER V9.00   1                                                                     08/16/2012 21:41:13 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE 1
OBJECT MODULE PLACED IN 1.OBJ
COMPILER INVOKED BY: D:\安装软件\keil 51\C51\BIN\C51.EXE 1.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1                                                                                   /*实现功能:对颜色传感器输出RGB
   2          得出数据后可到http://www.59178.com/tools/sejie.asp查询数据是否正确
   3          使用芯片：AT89S52 或者 STC89C52 或AT89S51 STC89C51
   4          晶振：12MHZ
   5          编译环境：Keil
   6          作者：zhengzhongxign39*/
   7          #include <reg52.h>
   8          #define uchar unsigned char
   9          #define uint  unsigned int
  10          //==============LCD1602接口连接方法=====================
  11          /*-----------------------------------------------------
  12                 |DB0-----P0.0 | DB4-----P0.4 | RW-------P2.3    |
  13                 |DB1-----P0.1 | DB5-----P0.5 | RS-------P2.4    |
  14                 |DB2-----P0.2 | DB6-----P0.6 | E--------P2.2    |
  15                 |DB3-----P0.3 | DB7-----P0.7 | 
  16              ---------------------------------------------------*/
  17          //================================================*/              
  18          #define LCM_Data     P2    //LCD1602数据接口
  19          #define Busy         0x80   //用于检测LCM状态字中的Busy标识
  20          sbit    LCM_RW     = P0^6;  //读写控制输入端，LCD1602的第五脚
  21          sbit    LCM_RS     = P0^7;  //寄存器选择输入端，LCD1602的第四脚
  22          sbit    LCM_E      = P0^5;  //使能信号输入端,LCD1602的第6脚
  23          
  24          //=================颜色传感模块连接=====================
  25          /*-----------------------------------------------------
  26                 |EO-----GND
  27                 |S0-----VCC | S2-----P1.0 | OUT-------P3.5 
  28                 |S1-----VCC | S3-----P1.1 | 
  29            ---------------------------------------------------*/
  30          sbit    tcs230_s2=P1^0;//TCS230 S2接单片机P1.0
  31          sbit    tcs230_s3=P1^1;//TCS230 S3接单片机P1.1
  32          sbit    tcs230_en=P3^0; //TCS230 EN(E0)接GND
  33          //**************函数声明***************************************
  34          void    WriteDataLCM            (uchar WDLCM);//LCD模块写数据
  35          void    WriteCommandLCM (uchar WCLCM,BuysC); //LCD模块写指令
  36          uchar   ReadStatusLCM(void);//读LCD模块的忙标
  37          void    DisplayOneChar(uchar X,uchar Y,uchar ASCII);//在第X+1行的第Y+1位置显示一个字符
  38          void    LCMInit(void);//LCD初始
  39          void    DelayMs(uint Ms);//1MS基准延时程序
  40          void    baipingheng();//白平衡子程序
  41          void    celiang();//实际颜色程序
  42          uint    ryz,gyz,byz;//分别定义红色因子 绿色因子 蓝色因子
  43          uint    rb,gb,bb;//RGB值
  44          uchar   tab1[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
  45          //***********************主程序******************************
  46          main()   
  47          {   
  48   1         TMOD=0x51;//设定T0以工作方式1定时10毫秒
  49   1         LCMInit();//LCD初始
  50   1         baipingheng();//上电时先白平衡一次
  51   1         while(1)
  52   1         {
  53   2             celiang();//颜色测试
  54   2             DisplayOneChar(0, 0,'R');//以十进制显示RGB中红色的分值
  55   2             DisplayOneChar(0, 1, rb/100+0x30); //显示百位数据
C51 COMPILER V9.00   1                                                                     08/16/2012 21:41:13 PAGE 2   

  56   2             DisplayOneChar(0, 2, rb/10%10+0x30);//显示十位数据
  57   2             DisplayOneChar(0, 3, rb%10+0x30);//显示个位数据
  58   2             DisplayOneChar(0, 5,'G');//以十进制显示RGB中绿色的分值
  59   2             DisplayOneChar(0, 6, gb/100+0x30); //显示百位数据
  60   2             DisplayOneChar(0, 7, gb/10%10+0x30);
  61   2             DisplayOneChar(0, 8, gb%10+0x30);
  62   2             DisplayOneChar(0, 10,'B');//以十进制显示RGB中蓝色的分值
  63   2             DisplayOneChar(0, 11, bb/100+0x30);
  64   2             DisplayOneChar(0, 12, bb/10%10+0x30);
  65   2             DisplayOneChar(0, 13, bb%10+0x30);
  66   2             //*****在LCD1602的第二行以16进制显示RGB*******************
  67   2             DisplayOneChar(1, 1, tab1[rb/16]); 
  68   2             DisplayOneChar(1, 2, tab1[rb%16]);
  69   2             DisplayOneChar(1, 3, 'H');
  70   2             DisplayOneChar(1, 6, tab1[gb/16]); 
  71   2             DisplayOneChar(1, 7, tab1[rb%16]);
  72   2             DisplayOneChar(1, 8, 'H');
  73   2             DisplayOneChar(1, 11,tab1[bb/16]);
  74   2             DisplayOneChar(1, 12,tab1[bb%16]);
  75   2             DisplayOneChar(1, 13,'H');
  76   2             DelayMs(250);//每隔0.25秒测试一次颜色
  77   2         }
  78   1      } 
  79          //******************************************************
  80          //白平衡子程序
  81          void   celiang()
  82          {
  83   1           //*********求R值************************************
  84   1           TH0=(65536-10000)/256;
  85   1               TL0=(65536-10000)%256;
  86   1           TH1=0;
  87   1           TL1=0;
  88   1           tcs230_s2=0;
  89   1           tcs230_s3=0;//选择红色滤光器
  90   1           tcs230_en=0;
  91   1           TR0=1;//10毫秒开始计时
  92   1           TR1=1;//开始计数
  93   1           while(TF0==0);//等待定时器溢出
  94   1           TF0=0;//清楚定时器0溢出标志
  95   1           TR0=0;//关闭定时0
  96   1           TR1=0;
  97   1           rb=(unsigned long)(TH1*256+TL1)*255/ryz;
  98   1           if(rb>255)rb=255;//判断RGB值是否合法
  99   1           //***********求B值**************************************
 100   1           TH0=(65536-10000)/256;
 101   1               TL0=(65536-10000)%256;
 102   1           TH1=0;
 103   1           TL1=0;
 104   1           tcs230_s2=0;
 105   1           tcs230_s3=1;//选择蓝色滤光器
 106   1           TR0=1;//10毫秒开始计时
 107   1           TR1=1;//开始计数
 108   1           while(TF0==0);//等待定时器溢出
 109   1           TF0=0;//清楚定时器0溢出标志
 110   1           TR0=0;//关闭定时0
 111   1           TR1=0;
 112   1           bb=(unsigned long)(TH1*256+TL1)*255/byz;
 113   1           if(bb>255)bb=255;//判断RGB值是否合法     
 114   1           //***********求G值**************************************   
 115   1           TH0=(65536-10000)/256;
 116   1               TL0=(65536-10000)%256;
 117   1           TH1=0;
C51 COMPILER V9.00   1                                                                     08/16/2012 21:41:13 PAGE 3   

 118   1           TL1=0;
 119   1           tcs230_s2=1;
 120   1           tcs230_s3=1;//选择绿色滤光器
 121   1           TR0=1;//10毫秒开始计时
 122   1           TR1=1;//开始计数
 123   1           while(TF0==0);//等待定时器溢出
 124   1           TF0=0;//清楚定时器0溢出标志
 125   1           TR0=0;//关闭定时0
 126   1           TR1=0;
 127   1           tcs230_en=1;
 128   1           gb=(unsigned long)(TH1*256+TL1)*255/gyz;
 129   1           if(gb>255)gb=255;//判断RGB值是否合法  
 130   1      }
 131          //******************************************************
 132          //白平衡子程序
 133          void    baipingheng()
 134          {
 135   1           //**************求取红色因子***********************
 136   1           TH0=(65536-10000)/256;
 137   1               TL0=(65536-10000)%256;
 138   1           TH1=0;
 139   1           TL1=0;
 140   1           tcs230_s2=0;
 141   1           tcs230_s3=0;//选择红色滤光器
 142   1           tcs230_en=0;
 143   1           TR0=1;//10毫秒开始计时
 144   1           TR1=1;//开始计数
 145   1           while(TF0==0);//等待定时器溢出
 146   1           TF0=0;//清楚定时器0溢出标志
 147   1           TR0=0;//关闭定时0
 148   1           TR1=0;
 149   1           ryz=TH1*256+TL1;//其实这里的比例因子应该为255/(TH1*256+TL1)
 150   1           //**************求取蓝色因子***********************
 151   1           TH0=(65536-10000)/256;
 152   1               TL0=(65536-10000)%256;
 153   1           TH1=0;
 154   1           TL1=0;
 155   1           tcs230_s2=0;
 156   1           tcs230_s3=1;//选择蓝色滤光器
 157   1           TR0=1;//10毫秒开始计时
 158   1           TR1=1;//开始计数
 159   1           while(TF0==0);//等待定时器溢出
 160   1           TF0=0;//清楚定时器0溢出标志
 161   1           TR0=0;//关闭定时0
 162   1           TR1=0;
 163   1           byz=TH1*256+TL1;//其实这里的比例因子应该为255/(TH1*256+TL1)
 164   1           //**************求绿红色因子***********************
 165   1           TH0=(65536-10000)/256;
 166   1               TL0=(65536-10000)%256;
 167   1           TH1=0;
 168   1           TL1=0;
 169   1           tcs230_s2=1;
 170   1           tcs230_s3=1;//选择绿色滤光器
 171   1           TR0=1;//10毫秒开始计时
 172   1           TR1=1;//开始计数
 173   1           while(TF0==0);//等待定时器溢出
 174   1           TF0=0;//清楚定时器0溢出标志
 175   1           TR0=0;//关闭定时0
 176   1           TR1=0;
 177   1           tcs230_en=1;
 178   1           gyz=TH1*256+TL1;//其实这里的比例因子应该为255/(TH1*256+TL1)
 179   1      }
C51 COMPILER V9.00   1                                                                     08/16/2012 21:41:13 PAGE 4   

 180          /*======================================================================
 181           LCM初始化
 182          ======================================================================*/
 183          void LCMInit(void) 
 184          {
 185   1       LCM_Data = 0;
 186   1       WriteCommandLCM(0x38,0); //三次显示模式设置，不检测忙信号
 187   1       DelayMs(5);
 188   1       WriteCommandLCM(0x38,0);
 189   1       DelayMs(5);
 190   1       WriteCommandLCM(0x38,0);
 191   1       DelayMs(5);
 192   1       WriteCommandLCM(0x38,1); //显示模式设置,开始要求每次检测忙信号
 193   1       WriteCommandLCM(0x08,1); //关闭显示
 194   1       WriteCommandLCM(0x01,1); //显示清屏
 195   1       WriteCommandLCM(0x06,1); // 显示光标移动设置
 196   1       WriteCommandLCM(0x0C,1); // 显示开及光标设置
 197   1       DelayMs(100);
 198   1      }
 199          //==============================LCD1602显示子程序================================================
 200          // 写数据函数: E =高脉冲 RS=1 RW=0
 201          //======================================================================*/
 202          void WriteDataLCM(uchar WDLCM)
 203          {
 204   1       ReadStatusLCM(); //检测忙
 205   1       LCM_Data = WDLCM;
 206   1       LCM_RS = 1;
 207   1       LCM_RW = 0;
 208   1       LCM_E = 0; //若晶振速度太高可以在这后加小的延时
 209   1       LCM_E = 0; //延时
 210   1       LCM_E = 1;
 211   1      }
 212          /*====================================================================
 213            写指令函数: E=高脉冲 RS=0 RW=0
 214          ======================================================================*/
 215          void WriteCommandLCM(uchar WCLCM,BuysC) //BuysC为0时忽略忙检测
 216          {
 217   1       if (BuysC) ReadStatusLCM(); //根据需要检测忙
 218   1       LCM_Data = WCLCM;
 219   1       LCM_RS = 0;
 220   1       LCM_RW = 0;
 221   1       LCM_E = 0;
 222   1       LCM_E = 0;
 223   1       LCM_E = 1;
 224   1      }
 225          /*====================================================================
 226            正常读写操作之前必须检测LCD控制器状态:E=1 RS=0 RW=1;
 227            DB7: 0 LCD控制器空闲，1 LCD控制器忙。
 228            读状态
 229          ======================================================================*/
 230          uchar ReadStatusLCM(void)
 231          {
 232   1       LCM_Data = 0xFF;
 233   1       LCM_RS = 0;
 234   1       LCM_RW = 1;
 235   1       LCM_E = 0;
 236   1       LCM_E = 0;
 237   1       LCM_E = 1;
 238   1       while (LCM_Data & Busy); //检测忙信号  
 239   1       return(LCM_Data);
 240   1      }
 241          /*======================================================================
C51 COMPILER V9.00   1                                                                     08/16/2012 21:41:13 PAGE 5   

 242          功 能:     在1602 指定位置显示一个字符:第一行位置0~15,第二行16~31
 243          说 明:     第 X 行,第 y 列  注意:字符串不能长于16个字符
 244          ======================================================================*/
 245          void DisplayOneChar( uchar X, uchar Y, uchar ASCII)
 246          {
 247   1        X &= 0x1;
 248   1        Y &= 0xF; //限制Y不能大于15，X不能大于1
 249   1        if (X) Y |= 0x40; //当要显示第二行时地址码+0x40;
 250   1        Y |= 0x80; // 算出指令码
 251   1        WriteCommandLCM(Y, 0); //这里不检测忙信号，发送地址码
 252   1        WriteDataLCM(ASCII);
 253   1      }
 254          /*====================================================================
 255            设定延时时间:x*1ms
 256          ====================================================================*/
 257          void DelayMs(uint Ms)
 258          {
 259   1        uint i,TempCyc;
 260   1        for(i=0;i<Ms;i++)
 261   1        {
 262   2          TempCyc = 250;
 263   2          while(TempCyc--);
 264   2        }
 265   1      }
 266          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1033    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
